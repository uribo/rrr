[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Rによる再現可能なデータ分析",
    "section": "",
    "text": "前書き\nコンピュータを用いた統計解析は、現代の統計学やデータサイエンスにおいて重要な役割を果たしています。 膨大かつ多様性を増しているビッグデータを扱う際には、コンピュータによる効率的なデータ処理と解析が不可欠であり、これにはデータの処理速度やデータの多様性に対応できる技術が求められます。 また、人工知能（AI）分野では、統計モデルを基盤とした機械学習手法が不可欠であり、その多くは大規模なデータセットを基に、コンピュータを利用してパターンを学習しています。\nコンピューターを使ったデータ分析が進む中、データ分析の過程を再現可能にすることが重要視されています。 再現可能性とは、分析者自身を含めた他者が同じデータ・ソースコードを使って同じ結果を得られることを指します。 再現可能性が確保されていることで、データ分析の過程や結果を他者に説明しやすくなり、信頼性の高いデータ分析を行うことができます。\n近年、データ分析を伴う学術研究の中で、第三者や自分自身の研究結果を再現しようとして失敗する「再現性の危機」と呼ばれる問題が報告されています。 どうすればデータ分析に再現性を持たせることができるのか、そのためにはどのような手法を用いるべきなのか、といった問題に対して、研究者やデータ分析者は真剣に取り組む必要があります。\n私たちはデータ分析の手法や背景にある数学、統計学の知識を学び、実現するためのプログラミング技術を磨いてきました。 しかし分析作業の再現可能性については、学ぶ機会が少なかったり、普段意識していないかもしれません。\n「誰が再現性を必要としている？」という問いに対して、あなたはどのように答えますか？\n以前行ったデータ分析の結果が再現できず、時間を割いた経験がある人は、その必要性について否定的な意見を持つことは少ないでしょう。 再現可能性を必要としているのは、あなた自身であり、あなたのチームであり、あなたの成果を利用する他者を含みます。 これら全ての人々を意識するのは困難かもしれませんが、まず身近で作業する人たちのために再現可能性を確保することが重要となります。\n再現可能性にはいくつかの段階があり、どこにゴールを置くかは状況によって異なります。 ゴールはデータとソースコードを残し、あくまでも自分だけが再現できる状況を残すことなのか、さらに一歩進んで実行環境の情報を提供するのかといった具合です。 さらに完全な再現は困難である点も認識しておく必要があります。\n本書の目標は、再現可能なデータ分析に取り組む全員が再現可能なデータ分析に必要な考えや能力を身につけることです。 実際のデータ分析で本書のどの内容が適用されるかは、読者自身が判断することになります。 本書の内容が、あなたのデータ分析の再現可能性に対する考え方や作業を改善する一助となれば幸いです。",
    "crumbs": [
      "前書き"
    ]
  },
  {
    "objectID": "index.html#構成",
    "href": "index.html#構成",
    "title": "Rによる再現可能なデータ分析",
    "section": "構成",
    "text": "構成\n本書では、データ分析の過程において再現可能性を確保するための手法を学びます。 R言語を題材としますが、多くの考えが他のプログラミング言語でも適用できるはずです。\n再現可能性と関係するコンピューターおよびプログラミングに関する基礎知識を身につけることから着手します（第1章）。 次の第2章では、R言語によるプログラミングの作業において、再現可能性を低下させる要因を理解します。 再現可能なデータ分析の第一歩として、データ分析をプロジェクトとして捉えて組織化することを学びます（第3章）。 統合開発環境を導入することで次の章からの再現可能性を高める手法の実践が容易になります。 第4章では、データ分析の作業を記録し共有するためのバージョン管理システムを導入します。\n第5章からは、データ分析作業においてのさらに具体的な場面での再現可能性の手法に取り組みます。 まず、分析結果をレポートなどにまとめるためのドキュメントの生成を学びます（第5章）。 続いてRで利用可能な再現可能性を高めるパッケージを紹介し（第6章）、特に第7章でtargetsパッケージを用いたプロジェクトのワークフロー化を学びます。 第8章では、コンテナ技術によるデータ分析環境の構築を目指します。",
    "crumbs": [
      "前書き"
    ]
  },
  {
    "objectID": "index.html#本書の再現",
    "href": "index.html#本書の再現",
    "title": "Rによる再現可能なデータ分析",
    "section": "本書の再現",
    "text": "本書の再現\n本書は以下の環境で執筆されました。GitHubリポジトリ https://github.com/uribo/rrr に関係するファイルを公開しています。 リポジトリからファイルをダウンロードし、RStudioで rrr.Rproj を開いたうえで起動するプロジェクトから、本書の再現を試みることができます。\n\nmacOS Sonoma 14.6.1 および Ubuntu 22.04.4 LTS (GitHub pagesへのデプロイ)\nR version 4.1.1\nRStudio\nQuarto\nrenv\n\n次のコードを実行すると、本書の復元が行われます。 ここで行われるのは、renvによるパッケージの整備とQuartoによるドキュメントの生成です。\n\nrenv::restore()\n\nquarto::quarto_render()\n\n本書の内容を補足するサンプルコードをGitHubリポジトリで公開しています。こちらも合わせてご利用ください。\nhttps://github.com/uribo/rrr-demo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 22.04.4 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: UTC\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.37     fastmap_1.2.0     xfun_0.47         knitr_1.48       \n [5] htmltools_0.5.8.1 rmarkdown_2.28    lifecycle_1.0.4   cli_3.6.3        \n [9] textshaping_0.4.0 renv_1.0.7        systemfonts_1.1.0 compiler_4.4.1   \n[13] tools_4.4.1       ragg_1.3.2        evaluate_0.24.0   yaml_2.3.10      \n[17] rlang_1.1.4       jsonlite_1.8.8    htmlwidgets_1.6.4",
    "crumbs": [
      "前書き"
    ]
  },
  {
    "objectID": "literacy.html",
    "href": "literacy.html",
    "title": "1  基礎（リテラシー）",
    "section": "",
    "text": "1.1 ディレクトリとパス\nコンピュータ上のファイルやディレクトリ（フォルダ）は、それぞれ一意の場所を持っています。 この場所を示すために、フォルダやファイルにはパス（path）と呼ばれるものが与えられます。 パスは、ファイルやディレクトリの住所のような存在で、文字列で表現されます。\nパスは、プログラムの実行時に重要な役割を果たします。 プログラムがファイルを読み込む際や、ファイルを書き込む際には、そのファイルのパスを指定する必要があります。 そのためプログラム初心者が最初につまづく要因の一つが、パスの指定方法です。 パスは正確に記述しないと、プログラムがファイルを特定できないためにエラーが発生します。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>基礎（リテラシー）</span>"
    ]
  },
  {
    "objectID": "literacy.html#ディレクトリとパス",
    "href": "literacy.html#ディレクトリとパス",
    "title": "1  基礎（リテラシー）",
    "section": "",
    "text": "1.1.1 Rにおける作業ディレクトリ\nRを使う際には、作業ディレクトリ（working directory）という概念が重要です。 作業ディレクトリは、Rがファイルを読み込む際や書き込む際の基準となるディレクトリです。 作業ディレクトリは特定のフォルダを指定します。 通常はユーザーのホームディレクトリが作業ディレクトリとなりますが、必要に応じてsetwd()関数を使用して変更可能です。\n\n\n\n作業ディレクトリ。GUI Rを開いたときに確認できる。ここでは~/Documentsが作業ディレクトリとなっている。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>基礎（リテラシー）</span>"
    ]
  },
  {
    "objectID": "literacy.html#環境",
    "href": "literacy.html#環境",
    "title": "1  基礎（リテラシー）",
    "section": "1.2 環境",
    "text": "1.2 環境\nコンピュータには、プログラムが動作するために必要な条件、設定が存在します。 この条件や設定のことを「環境」と呼びます。 環境はコンピュータのOS（オペレーティングシステム）、ハードウェア、ソフトウェア、ネットワークなど、さまざまな要素で構成されています。 そのため、コンピュータ間で同じ環境を用意することは容易ではありません。\n環境の違いは、プログラムの動作に影響を与えることがあります。 例えば、あるコンピュータで動作するプログラムが、別のコンピュータで動作しなかったり、出力結果が異なることがあります。 例を見てみましょう。 Rの作業ディレクトリを示す getwd() 関数をmacOSとWindowsで実行した場合、それぞれのOSに応じたディレクトリが表示されます。 以下は著者のR実行環境であるmacOSでの実行結果ですが、Windowsで実行した場合、ディレクトリの先頭は通常 C:/ となります。\n\ngetwd()\n\n[1] \"/home/runner/work/rrr/rrr\"",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>基礎（リテラシー）</span>"
    ]
  },
  {
    "objectID": "literacy.html#プログラムのバージョン",
    "href": "literacy.html#プログラムのバージョン",
    "title": "1  基礎（リテラシー）",
    "section": "1.3 プログラムのバージョン",
    "text": "1.3 プログラムのバージョン\nプログラムは通常、バージョン（版）を示すための番号であるバージョン番号を持っています。 バージョン番号を見ることで、そのプログラムの新しさを知ることができます。\nプログラムは一度作成されると、その後も更新されていくのが普通です。 完成したプログラムにバグ修正や機能追加が行われると、バージョン番号が更新されます。 バージョン番号を見ることで、そのプログラムが新しいものなのか、また、リリースノートなどの情報を見ることで、どのような変更が行われたのか、どのような機能を持っているのかを知ることができます。\nバージョンの違いは環境の違いの一因となります。 あるバージョンでは実装されていないプログラムがあったり、 バージョンが古いために挙動が異なることがあります。\n\n1.3.1 セマンティックバージョニング\nバージョンの表記方法にはさまざまな形式があります。 その中で、セマンティックバージョニング（Semantic Versioning）は、バージョン番号の付け方の一つです。 バージョン番号を、Major.Minor.Patchの3つの数字で構成されます。\n\n\n\njmastatsパッケージのバージョン。0.2.2と示される通り、Minorバージョン2において2つ目の修正が行われたことがわかる。\n\n\n例えば1.2.3のバージョンは、Majorが1、Minorが2、Patchが3です。 バージョン番号を構成する3つの数字の意味は以下の通りです。 Majorは互換性がない変更があった場合に増やします。 Minorは互換性がある機能追加があった場合に増やします。 Patchは互換性があるバグ修正があった場合に増やします。\nセマンティックバージョニングは、バージョン番号の付け方を開発者間で統一することで、バージョン番号だけで互換性の情報を得られるようにするためのルールです。 上記のような規則がありますが、実際にはこの規則に従っていない場合もあります。\n\n\n1.3.2 Rのバージョン\nRのバージョンはセマンティックバージョニングと同様に3桁の数字で構成されています。 年度初めの4月下旬に新しいメジャーあるいはマイナーバージョンがリリースされることが多く、 その年度内には3、4回のパッチバージョンアップが行われるのが通例です。\n本書執筆時の最新版は、2024年6月にリリースされたR4.4.1です。 利用しているRのバージョンはR起動時のメッセージや versionの実行などで確認できます。\nRでのバージョンの違いは、R本体の機能だけでなく、インストール可能なパッケージにも影響を与えます。 パッケージによっては、動作条件に特定のRバージョンが必要となることがあります。 また、第3章以降で導入する統合開発環境のRStudioの実行にはR3.6.0以上が必要です。\n\n\n1.3.3 バージョン更新の方針\nプログラムのバージョンは日々更新されています。 そのため、バージョンを最新版に保つことが重要です。 一方、バージョンを更新することで、以前のバージョンとの互換性がなくなることがあります。 また、複数人で実行するプログラムの場合、環境間でのバージョンの違いが問題となることがあります。 そのため、バージョンを更新する際には、その影響を十分に検討し、事前に方針を決めておくことが重要です。\n一つの方針として、常に最新のバージョンを利用することが挙げられます。 先に書いたような利点がありますが、プログラムに関わる全員が最新版を利用できる環境であることが前提となります。 もう一つの方針は、安定版を利用することです。 安定版は、バグが少なく、互換性が高いため、安定して利用できることが特徴です。 例えば最新バージョンが4.4.1である場合、4.3系の最新版である4.3.3を利用する、というような方針です。 この方針に従えばバージョン更新の手間を減らせますが、時間の経過とともに安定版の見直しを行うと良いでしょう。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>基礎（リテラシー）</span>"
    ]
  },
  {
    "objectID": "reproducibility.html",
    "href": "reproducibility.html",
    "title": "2  再現可能性",
    "section": "",
    "text": "2.1 再現性を阻害する要因\nR言語はプログラミング言語の一種であるため、プログラムやデータによって結果が変わることがあります。 特に意識しておくべき要因として、以下のようなものがあります。\n環境については前章で述べたとおり、 Rのバージョンやパッケージのバージョン、OSなどが該当します。\n環境変数とは、名前の通り、環境に関する情報を保持する変数のことです。 R言語では、環境変数を設定することで、Rの挙動を変えることができます。\nもう一つのランダム性は、乱数を利用する関数を使う場面で発生します。 乱数を使う関数は、実行のたびに異なる値を返すために再現性が損なわれる原因となります。\n具体例を見てみましょう。 標準正規分布に従う乱数を、rnorm関数を使って生成してみます。 同じ関数・引数であっても実行のたびに異なる結果が得られます。\n# 乱数生成アルゴリズムを利用する関数では、実行の度に出力が変化する。\nrnorm(n = 1)\n\n[1] -0.7194826\n\nrnorm(n = 1)\n\n[1] -0.5341494\n乱数の利用は、シミュレーションやモンテカルロ法などの分野で重要ですが、 再現性を確保するためには、set.seed()関数を使って乱数生成アルゴリズムのシードを固定する必要があります。\nset.seed(123)\n\nrnorm(n = 1)\n\n[1] -0.5604756\nset.seed()関数は、乱数を利用する関数の実行前に呼び出します。 引数には単一の整数を指定します。 この値が乱数のシードとして使われ、同じシードを指定すると同じ乱数が生成されるようになり、結果が再現可能になります。\nそのため、私は上記の結果がどのような値になるかを知っています。 私の予言が正しければ、 -0.5604756となるはずです。 乱数はRのさまざまな関数で利用されるため、再現性が求められる場面ではset.seed()関数を意識することが大事です。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>再現可能性</span>"
    ]
  },
  {
    "objectID": "reproducibility.html#再現性を阻害する要因",
    "href": "reproducibility.html#再現性を阻害する要因",
    "title": "2  再現可能性",
    "section": "",
    "text": "環境、環境変数の違い\nランダム性\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.Rprofile\n\n\n\nRでは、.Rprofileに書かれた内容が起動時に実行されます。 このファイルは起動時に読み込まれるので、Rの起動中に適用するオプションや環境変数などが記述されます。 これにより、毎回オプションを設定する手間が省けます。 よく使うパッケージを読み込む、デフォルトのグラフィックデバイスを設定する、さまざまな指定が可能です。\n\n\n\n2.1.1 reprexパッケージ\nソースコードが再現性をもつことや、第三者に状況を伝えるためには、再現可能な例を示す必要があります。 ここでの再現可能には、エラーの出力も含まれます。 reprexパッケージを使うと、Rのコードとその出力を含む再現可能な例（reproducible example）を作成できます。\n使い方は、reprex()関数内に再現の対象とするコードを記述し、実行するだけです。\n\nlibrary(reprex)\nreprex({\n  set.seed(123)\n  rnorm(n = 1)\n})\n\nコードを実行すると、実行中のRセッションとは別のRセッションが立ち上がり、再現可能な例が作成されます。 作成された例は、コンソールに表示されるだけでなく、クリップボードにコピーされるため、簡単に共有できます。 外部出力のために結果をテキストファイルに保存することもできます。\nreprexパッケージの便利な点は、実行環境の情報も含めて再現可能な例を作成できることです。 reprex()関数の引数にsession_info = TRUEを指定すると、セッション情報も出力されるので、コードの外にある環境についても再現性を検証する題材として使えるようになります。\n\n# session_info = TRUEを指定すると、セッション情報も出力される。\n# wd引数で作業ディレクトリを指定する。ここでは現在の作業ディレクトリを指定し、実行コードと結果が外部ファイルに保存するようにした。\nreprex({\n  print(\"hello\")\n}, \n  session_info = TRUE, \n  wd = \".\")\n\n実際、Rコードの不具合を報告する際には、再現可能な例を示すことが求められることがあります。 GitHub issuesやStack Overflow、Slackなどで質問する際には、reprexパッケージを使って再現可能な例を作成すると、問題の解決がスムーズに進むことがあります。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>再現可能性</span>"
    ]
  },
  {
    "objectID": "reproducibility.html#rig",
    "href": "reproducibility.html#rig",
    "title": "2  再現可能性",
    "section": "2.2 rig",
    "text": "2.2 rig\nRを使ったデータ分析を行う際、複数のRのバージョンを使い分ける必要が生じることがあります。 古いバージョンのRで書かれたソースコードを実行する場合、新しいバージョンとは結果が変わっている可能性があります。 これにはデフォルトの挙動の変化1や乱数生成のアルゴリズムの変更2などが影響します。\nRでは、4.1、4.0のようにマイナーバージョンごとに異なるバージョンを共存させることが可能ですが、実際にバージョンを切り替えるのは手間がかかります。 そこで、Rのバージョン管理ツールであるrigが役立ちます。 rigを使うことで、複数のRのバージョンを共存、切り替えが容易に行えるようになります。\nリリースされている最新のRをインストールするには以下のコマンドを実行します。\nrig add release\nまた、macOS限定になりますが、メニューバーからRStudioのプロジェクト機能（第3章参照）と連動し、最近起動したrprojファイルを任意のバージョンで起動できるようになります。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>再現可能性</span>"
    ]
  },
  {
    "objectID": "reproducibility.html#footnotes",
    "href": "reproducibility.html#footnotes",
    "title": "2  再現可能性",
    "section": "",
    "text": "R 4.4.0からはdata.frame()関数で利用される引数として、stringsAsFactors = FALSEがデフォルトになりました。これにより、文字列型のデータがデフォルトでfactors型に変換されなくなりました。 そのため、古いバージョンのRで書かれたコードを新しいバージョンのRで実行すると、データの型が変わる可能性があります。↩︎\nR 3.6.0から、乱数生成アルゴリズムが変更されました。↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>再現可能性</span>"
    ]
  },
  {
    "objectID": "project.html",
    "href": "project.html",
    "title": "3  プロジェクト",
    "section": "",
    "text": "3.1 統合開発環境\nプログラム開発で必要なエディタやコンパイラ、デバッガなどのツールを一つにまとめたものを統合開発環境（IDE: Integrated Development Environment）と呼びます。 Rは単体のアプリケーションとして提供されていますが、RStudioやVS CodeというIDEを利用することで、より使いやすく、効率的に作業を行えるようになる利点があります。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>プロジェクト</span>"
    ]
  },
  {
    "objectID": "project.html#rstudio",
    "href": "project.html#rstudio",
    "title": "3  プロジェクト",
    "section": "3.2 RStudio",
    "text": "3.2 RStudio\nRStudioは、RおよびPythonのための統合開発環境（IDE）です。 Posit（旧RStudio）により開発されており、無償で利用可能なものとしてデスクトップ版とサーバー版が存在します。 デスクトップ版の実行には、R 3.6.0以上のインストールが必要です。\nRStudioの特徴は、Rの実行に必要、利便性を高める機能を「ペイン」と呼ばれる区画に分けて表示していることです。 ペインはさらに複数のタブを持つことができます。 例えば、ソースコードを編集するソースペインでは、タブにより複数のファイルを開くことができます。 セッションで生成したオブジェクトについて把握できるEnvironタブや、プロットした図を表示させるPlotsタブなど、さまざまなタブ機能が用意されています。 これらのRStudioの機能は 松村優哉 ほか (2021) に詳しく記載されています。\n\n3.2.1 RStudioのプロジェクト\nRStudioではプロジェクト機能を利用して、データやコード、成果物を一つのまとまりとして扱うことができます。 またGitバージョン管理との連携も可能です。 このことは次章で詳しく説明します。\nプロジェクトの作成はメニューバーあるいはrstudioapiパッケージの関数を使って行います。 メニューバーでは、File、New Projectの順に進むと、新規のフォルダにプロジェクトを用意するか、既存のフォルダをプロジェクトとして扱うか、あるいはバージョン管理システムを利用するかの選択を行う画面が表示されます。\nここでは新規フォルダにプロジェクトを用意する前提で進めます。 RStudioでは、パッケージの開発やShinyアプリケーションなど、用途に応じたプロジェクトのテンプレートが用意されており、目的に応じて選択することができます。 一般的なデータ分析プロジェクトを作成する場合は、New Directoryを選択します。\n次の画面でプロジェクトの名前と保存先を指定します。 簡潔で明瞭なプロジェクト名をつけるとよいでしょう。 著者は、プロジェクトの保存先のフォルダ名に、プロジェクト発足の西暦をつけるようにしています。 また、プロジェクト名に西暦の末尾2桁をつけることも、プロジェクトの識別に役立つテクニックです。\n\n# rstudioapiパッケージを使ってプロジェクトを作成する\nrstudioapi::openProject(\"~/Documents/projects2024/rrr-demo\")\n\n プロジェクトを作成すると、プロジェクト用のディレクトリが作成され、その中にプロジェクトファイル（.Rproj）が作成されます。 プロジェクト作成後は、.Rprojファイルのあるディレクトリが作業ディレクトリとして設定されます。 RStudioでは、プロジェクトの利用を想定しているため、簡単にプロジェクトを切り替えたり、複数のプロジェクトを同時に立ち上げることが可能です。\nRStudioプロジェクトでは、プロジェクト単位で環境を管理します。 メニューバーの Tools、Project Optionsからプロジェクトの設定を変更できます。 ここでは、プロジェクト全般にかかわる設定、パイプ演算子の種類やタブの幅、バージョン管理システムの設定などを行うことができます。 これらの設定はプロジェクトを利用する全員に適用されます。\nプロジェクトの設定で特に重要なのは、作業空間に関する項目です。 立ち上げ時に.RDataを読み込むか、終了時に.RDataへの保存を行うか、履歴を保存するかの3つの項目について設定できます。 著者の考えでは、.RDataについてはいずれも No （読み込まない、保存しない）を選択することをお勧めします。 履歴については、Yesで良いでしょう。 ソースコードに残っていない履歴が、作業の再現に役立つこともあるためです。\n.RDataに関する設定を行わない理由を説明します。 .RDataはRの作業空間を保存するファイルです。 作成、定義したRオブジェクトが保存されるため、以前の作業状態を再現する際に便利です。 特に作成に時間がかかるオブジェクトを再利用する場合には有用です。 しかし、常にそれを行う必要性はありません。 利点よりも、.RDataの読み込みによって、起動時に意図しないオブジェクトが存在してしまう可能性を考慮するべきです。 また.RDataを読み込み・保存するようにすると、起動と終了時に時間がかかることもあります。\n ## VS Codeの利用\nMicrosoftが提供するVisual Studio Code (VS Code)もRの開発環境の選択肢となります。 標準ではRの実行環境は提供されていませんが、拡張機能をインストールすることでRStudioのようにコーディングから実行までシームレスに行うことができます。\nVS Codeでは、作業空間と呼ばれる単位で関連するファイルを管理します。 これはRStudioのプロジェクト機能と類似の考え方です。\nVS Codeの特徴は、Rだけでなくさまざまな言語の開発に対応していることです。 拡張機能を利用することで、ユーザーが必要とする機能を追加することができます。 拡張機能には、Git、GitHubとの連携を行うものやドキュメントの生成を容易に行うものなどがあります。 これによりデータ分析の作業を効率的に行うことが期待されます。\n\n\n3.2.2 Positron\n現時点で正式なリリースはされていませんが、PositがオープンソースのVS Codeをベースに開発を進めるPositronも注目されています。\nPositronの特徴は、RやPythonといったデータ分析で用いる言語の実行、ドキュメント作成に特化している点です。 RStudioのような環境変数の管理を、RだけでなくPythonの環境でも提供します。 またQuarto、Jupyterといったドキュメント生成ツールとの連携が容易に行えるようになっています。 これについてはドキュメントの章で取り上げます。\nVS Code同様に拡張機能によって、多様な機能を追加できる点も魅力の一つです。 VS Codeとの違いは、ライセンス上の問題からインストール可能な機能拡張は[Open VSX Registry] (https://open-vsx.org/)で管理されるものに限定されるという点です。 ここには数多くの拡張機能が登録されていますが、すべてではありません。 いくつかの拡張機能は本家のVS Codeでのみ利用可能です。\nまた、rig（第2章参照）などで複数バージョンのRが利用可能な環境であれば、 アプリケーションの中で任意のバージョンへの切り替えが可能です1。\n\n\n\nPositronでのR実行バージョンの切り替え",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>プロジェクト</span>"
    ]
  },
  {
    "objectID": "project.html#hereパッケージ",
    "href": "project.html#hereパッケージ",
    "title": "3  プロジェクト",
    "section": "3.3 hereパッケージ",
    "text": "3.3 hereパッケージ",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>プロジェクト</span>"
    ]
  },
  {
    "objectID": "project.html#ディレクトリ構成",
    "href": "project.html#ディレクトリ構成",
    "title": "3  プロジェクト",
    "section": "3.4 ディレクトリ構成",
    "text": "3.4 ディレクトリ構成\n- data/\n- data-raw/\n- R/\n- src/",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>プロジェクト</span>"
    ]
  },
  {
    "objectID": "project.html#スタイルガイド",
    "href": "project.html#スタイルガイド",
    "title": "3  プロジェクト",
    "section": "3.5 スタイルガイド",
    "text": "3.5 スタイルガイド\n\n3.5.1 stylerパッケージ\n\n\n3.5.2 lintrパッケージ\n\n\n\n\n松村優哉, 湯谷啓明, 紀ノ定保礼, と 前田和寛. 2021. RユーザのためのRStudio〈実践〉入門 : tidyverseによるモダンな分析フローの世界. 技術評論社. https://gihyo.jp/book/2021/978-4-297-12170-9.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>プロジェクト</span>"
    ]
  },
  {
    "objectID": "project.html#footnotes",
    "href": "project.html#footnotes",
    "title": "3  プロジェクト",
    "section": "",
    "text": "Positronの動作環境として、R 4.2.0以上、Pythonでは 3.8以上が必要です。これ以下のバージョンはインストールされていても利用できません。↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>プロジェクト</span>"
    ]
  },
  {
    "objectID": "git.html",
    "href": "git.html",
    "title": "4  バージョン管理",
    "section": "",
    "text": "4.1 バージョン管理の必要性\nデータ分析で用いるソースコードやデータは日々更新（バージョンアップ）されていきます。 ある日の作業では、データ読み込みのプログラムを書いて、次の日にはデータの前処理と可視化のプログラムを書くという流れです。 またある日には、これまで使っていたデータを新しいデータに差し替えることもあるでしょう。 そんな中で、ある日突然、以前実行可能だったコードがエラーを吐いたり、以前正常に動作していたコードが動かなくなったりすることがあります。\nバグとなるプログラムを書いてしまうことは誰にでもあることですが、そのような場合に、以前のバージョンに戻ることができると便利です。 別の場面として、複数人で共同作業を行う場合、いつだれがどのような変更を加えたのかを把握することも重要です。 分析に用いる解析手法の変更に気がつかず、誤ったコードを使って分析を行ってしまうことは避けるべきでしょう。\nバージョン管理システムを導入しないプロジェクトでは、ファイルが煩雑になりがちです。 どのファイルが最新のものなのか、どのデータを使うのかがわからなくなることもあります。\nバージョン管理は、このような問題を解決するための選択肢となります。 つまり、ファイルに対して、複数のバージョンを保存しておくこととと、共同作業を行う際に、誰がどのような変更を加えたのかを記録するのがバージョン管理の役割です。\n本書では、データ分析のためにバージョン管理システムを導入しますが、バージョン管理本来の目的は、プログラム開発においても同じです。 プログラム開発では、データ分析と同じく、長期にわたるプロジェクトや多くの開発者による共同作業です。 ソースコードを管理する点は変わりません。 データ分析の場合、ソースコードの他にデータやドキュメントも管理する必要がありますが、バージョン管理システムはそれらを一元管理することができます。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>バージョン管理</span>"
    ]
  },
  {
    "objectID": "git.html#バージョン管理の必要性",
    "href": "git.html#バージョン管理の必要性",
    "title": "4  バージョン管理",
    "section": "",
    "text": "とあるデータ分析プロジェクトでのフォルダ構成。あるファイルから派生したことが覗えるファイルが複数存在し、最終的にどのファイルを利用するのが適切なのかわからない状態。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>バージョン管理</span>"
    ]
  },
  {
    "objectID": "git.html#分散型バージョン管理システム-git",
    "href": "git.html#分散型バージョン管理システム-git",
    "title": "4  バージョン管理",
    "section": "4.2 分散型バージョン管理システム: Git",
    "text": "4.2 分散型バージョン管理システム: Git\n複数の開発者が共同でコードを管理・開発する際に便利な機能を提供するバージョン管理システムです。 バージョン管理システムには大別して2つの種類があります。 集中管理型は、ファイルの変更履歴を一つのリポジトリ（中央リポジトリ）に保存する方式です。 中央リポジトリはサーバー上に置かれるため、編集作業を行う際にはサーバーに接続する必要があります。\nもう一つが分散管理型です。 分散管理型は、ファイルの変更履歴を各ユーザーの端末にリポジトリ（リモートリポジトリ）のコピーをローカルリポジトリとして保存する方式です。 各自の端末で行われる編集作業が行われる点は集中管理型と変わりませんが、リモートリポジトリのコピーをローカルリポジトリとして持つことで、オフラインでも作業が可能です。 リモートリポジトリに変更を反映する際には、リモートリポジトリに変更をプッシュすることで、他のユーザーとの共有が可能です。\n\n\n\n分散管理型のバージョン管理システム\n\n\n分散管理型の代表として、Gitがあります。 Gitは、Linuxカーネルの開発者であるLinus Torvalds氏によって開発されました。\nGitが開発された背景には、Linuxカーネルの開発と、従来利用されていたバージョン管理システムであるBitKeeperの利用停止があります。 バージョン管理システムを模索する中、完全な分散型やブランチ機能を強化した新たなバージョン管理システムが必要とされました。 Gitの最初のリリースは2005年で、バージョン管理システムの中では比較的新しいものですが、現在では最も広く使われているバージョン管理システムの一つとなっています。\nここではGitのインストール方法を含めた詳細なGitの説明は行いません。横田紋奈 と 宇賀神みずき (2022) や 渡辺宙志 (2024) を参考にしてください。オンラインで読めるPro GitやRユーザー向けのHappy Git and GitHub for the useRもあります。\n\n4.2.1 リポジトリ\nGitではファイルやディレクトリの状態を記録し、変更履歴を管理する場所をリポジトリと呼びます。 リポジトリには、プロジェクトに関連するコードやファイルが含まれます。\nリポジトリは、性質の違いによりローカルリポジトリとリモートリポジトリに分けられます。 ローカルリポジトリは、自分のコンピュータ上に保存されているリポジトリです。 個々の開発者が自身の作業を管理し、変更履歴を保存するために使用されます。\nリモートリポジトリは、ネットワーク上のサーバーに保存されているリポジトリです。 ネットワークを介して、複数の開発者がアクセス可能であり、共同作業（共有と同期）を行うために使用されます。\nGitリポジトリを使った開発の流れは、開発者個人がそれぞれのローカルリポジトリで作業を行い、リモートリポジトリに変更を反映するというものです。 そのため、リモートリポジトリはバックアップとしての役割も果たします。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>バージョン管理</span>"
    ]
  },
  {
    "objectID": "git.html#バージョン管理の流れ",
    "href": "git.html#バージョン管理の流れ",
    "title": "4  バージョン管理",
    "section": "4.3 バージョン管理の流れ",
    "text": "4.3 バージョン管理の流れ\n最低限必要なコマンドを紹介しますので、まずはバージョン管理の雰囲気をつかんでください。 Gitバージョン管理は次の3つのステップで行います。\n\nリポジトリの作成\nファイルの追加\nファイルのコミット\n\nGitには100を超えるコマンドがありますが、覚えるべきコマンドは限定的です。 上記のバージョン管理の流れでは、それぞれ数個のコマンドを使います。 つまり、一連のバージョン管理で用いるコマンドは指で数えられる範囲に収まります。\n最初の作業は一度行えば、その後は実行する必要がなくなるので、実際は2つのステップとなります。\n\n4.3.1 リポジトリの作成\nこれからプロジェクトを立ち上げる、あるいは既存のプロジェクトをGitで管理する場合、まずリポジトリを作成します。 git initコマンドを実行すると、現在のディレクトリに.gitフォルダが作成されます。 このフォルダはGitリポジトリの中心的な役割を果たします。隠しフォルダとなっており、ユーザーが直接操作することはありません。\n\n\n4.3.2 ファイルの追加: ステージングエリアへの登録\nリポジトリにバージョン管理の対象とするファイルを追加するには、git addコマンドを使います。 リポジトリにファイルがない場合、何かファイルを作成してみてください。 その後、git statusというコマンドを実行すると Untracked files という箇所に作成したファイル名が表示されます。 この状態のファイルをリポジトリに追加するには、git addコマンドを使います。\n`git add &lt;ファイル名&gt;`\ngit addしたファイルは、ステージングエリアという仮想的な場所に追加されます。 ステージングエリアに追加されたファイルは、次にコミットする対象となります。\nUntracked状態のファイルが複数ある場合、git add .というコマンドを使うと、全てのファイルを一括で追加できます。\n\n\n4.3.3 ファイルのコミット\n作成・変更したファイルの状態を記録する作業をGitでは「コミット」と呼びます。 コミットを重ねることで、ファイルの変更履歴を残すことができ、必要に応じて過去の状態に遡ることができます。\nコミットの対象となるのは、ステージングエリアに追加されたファイルです。 そのためgit addを行う前にgit commitを行うと、コミット対象のファイルがないというエラーが表示されるので注意してください。\ngit commitコマンドを使って、ファイルの変更をコミットします。 コミットには、コミットメッセージと呼ばれる説明文を付けることができます。 作業後、コミットの履歴を見た際に、どのような変更を行ったかを把握するために重要な情報となります。 なぜその変更を行ったのか、どのような変更を行ったのかを記述します。\n\n\n\n\n\n\n最低限のGit設定\n\n\n\nコミットを行う際には、氏名とメールアドレスの設定が必要となります。 2つの設定は、Gitのコミットログで誰がコミットしたかを示すために必要な情報です。\nターミナルを開いて以下のコマンドを実行します。 二重引用符で示した箇所は適宜変更してください。\ngit config --global user.name \"&lt;あなたの名前&gt;\"\ngit config --global user.email \"&lt;あなたのメールアドレス&gt;\"\n設定が完了したかどうかは、以下のコマンドで確認できます。\ngit config --list\nこの出力でuser.nameとuser.emailが正しく表示されていれば、設定が完了しています。\n上記の処理はRパッケージであるusethisを使ってRからも行えます。\n\nlibrary(usethis)\nuse_git_config(user.name = \"&lt;あなたの名前&gt;\", \n               user.email = \"&lt;あなたのメールアドレス&gt;\")\n\n\n\nコミットメッセージは、以下のような形式で記述します。\n\n1行目: 変更内容の要約\n2行目: 空行\n3行目以降: 変更内容の詳細\n\nGitに不慣れな方は、コミットメッセージを書くことに障壁を感じるかもしれません。 しかし、難しく考える必要はありません。 ここで大事なことはコミットを残すことです。コミットメッセージは後から修正することもできますし、正解があるわけではありません。 簡単な情報であっても、コミットメッセージを残すことが大切です。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>バージョン管理</span>"
    ]
  },
  {
    "objectID": "git.html#アプリケーションを利用したバージョン管理",
    "href": "git.html#アプリケーションを利用したバージョン管理",
    "title": "4  バージョン管理",
    "section": "4.4 アプリケーションを利用したバージョン管理",
    "text": "4.4 アプリケーションを利用したバージョン管理\nGitはコマンドラインツールですが、GUIアプリケーションを使うことで、より簡単にバージョン管理を行うことができます。 Rの統合開発環境であるRStudioやVS Codeでも、Gitと連携した操作が可能です。 分析作業から離れずにバージョン管理を行うことができるため、非常に便利です。 すべてのコマンドを実行可能なわけではありませんが、基本的な操作はGUIを通して行えます。\n\n4.4.1 RStudio\nターミナルあるいはGitタブを使ってバージョン管理を行います。 ここではGUIで操作可能な方法を紹介します。 なおRStudioのGUIでは、GitとSVNによるバージョン管理をサポートしています。\n.gitフォルダが存在するプロジェクトを開くと、RStudioはGitタブを表示します。 この画面がRStudioでのGUIによるバージョン管理処理の中心となります。 もしもGitタブが見つからない場合、メニューのTools、Global Options…から、Git/SVNにてEnable version control interface for RStudio projectsにチェックを入れてください。\n\n\n\nRStudioにおけるGitタブ\n\n\nGitタブには、ファイルの差分やコミット履歴を確認するボタンが用意されています。 メインとなるのはStaged、Status、Pathの3列で構成される箇所です。 それぞれの列には次の意味があります。\n\nStaged: ステージングエリアに追加されたファイル\nStatus: ファイルの状態\nPath: ファイルのパス\n\nStagedはチェックボックスになっており、ステージングエリアに追加するファイルを選択できるようになっています。 これにより、git addコマンドを使わずにステージングエリアへの登録が行えます。 Shiftキーを押しながらの選択で、複数ファイルの選択も可能です。\n次のStatusには、いくつかのアイコンが表示されます。 各アイコンの意味は下記の通りです。\n\n\n\n\n\n\n\nアイコン\n状態\n\n\n\n\n? \nuntracked バージョン管理の対象になっていない\n\n\nModified \nリポジトリの状態から変更された\n\n\nDelete \nリポジトリにあったファイルが削除された\n\n\nAdded \n新たにバージョン管理状態になった\n\n\nUnmerged \nリポジトリ間で差分が衝突している\n\n\nRenamed \nファイル名が変更された\n\n\n\n\n\n4.4.2 VSCode\n\nリポジトリを初期化する",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>バージョン管理</span>"
    ]
  },
  {
    "objectID": "git.html#github",
    "href": "git.html#github",
    "title": "4  バージョン管理",
    "section": "4.5 GitHub",
    "text": "4.5 GitHub\nここまでで、Gitを使ったバージョン管理の基本的な操作を学びました。 次に、リモートリポジトリを利用して、複数人での共同作業を行う方法を紹介しましょう。 複数人と書きましたが、個人であってもリモートリポジトリを利用することで、バックアップ目的や異なるデバイスでの作業を行うために利用することができます。\nGitHub は、Gitリポジトリをホスティングするウェブサービス（リモートリポジトリ）です。 世界中のさまざまなプロジェクトで採用されるリモートリポジトリであり、オープンソースプロジェクトの共有やコラボレーションに広く利用されています。 ウェブサイトの閲覧は誰でもできますが、主要な機能を利用する際にはアカウントの作成が必要です。\nRパッケージのソースコードをGitHubで管理する開発者も多く、CRANで配布されるものだけでなく、CRANポリシーに適合しないなどの理由でCRANでは配布されないパッケージも豊富に存在します。 remotesやpakパッケージを使えば、これらのGitHub上で配布されるRパッケージのインストールも可能です。\nGitHub上のリポジトリには、誰でもアクセス可能なパブリックリポジトリと、特定のユーザーのみがアクセス可能なプライベートリポジトリの2種類があります。 プライベートリポジトリは、リポジトリの所有者と共同作業者（コラボレーター）のみがアクセスできるため、機密情報を扱うプロジェクトにも利用できます。\nGitHubにはここで取り上げる内容以外にも多くの機能があります。GitHub公式が提供するGitHub Skillsでは、実際のGitHubリポジトリを操作してGitHubの使い方を学ぶことができます。\n\n4.5.1 ローカルリポジトリの紐付け\nプロジェクトの章で作成したプロジェクト（rrr-demo）をGitHubと紐付けます。 まずはGitHub上で新しいリポジトリを作成します。 ここでリポジトリ名を指定しますが、混乱を避けるためにローカルリポジトリのプロジェクト名と同じ名前にしておくことを薦めます。\n\n\n\nGitHubでの新規リポジトリの作成\n\n\n作成したリポジトリのURLは https://github.com/&lt;アカウント名&gt;/&lt;リポジトリ名&gt; となります。 ページにアクセスすると、次の図のような画面が表示されます。 この状態ではリポジトリにファイルは存在していませんが、 作成したリモートリポジトリをローカルリポジトリに紐付けるための手順が書かれています。 2つの方法が示されていますが、一つは新しいローカルリポジトリを作成する方法、もう一つは既存のリポジトリをリモートリポジトリとして指定する方法です。 今回は後者の方法に従い、既存のローカルリポジトリをリモートリポジトリとして指定します。\n\n\n\n作成されたリモートリポジトリ\n\n\n書かれた内容をコピーし、ローカルリポジトリのディレクトリで実行します。 このコマンドでは、リモートリポジトリを origin という名前で登録しています。 origin はリモートリポジトリのデフォルトの名前として一般的に使われています。\n次に、ブランチ名の変更です。 GitHubでは、デフォルトのブランチ名として main が使用されています。 これに合わせるために、ローカルリポジトリのブランチ名を main に変更します。 そして、ローカルリポジトリで行った作業内容をリモートリポジトリに反映させるためにプッシュします。\ngit remote add origin https://github.com/uribo/rrr-demo.git\ngit branch -M main\ngit push -u origin main\nGitHubとの\n\n\n4.5.2 リモートリポジトリのクローン\n新しいコンピュータなど、ローカルリポジトリを持っていない場合には、リモートリポジトリをクローンします。\ngit clone\n\ngit clone https://github.com/uribo/rrr-demo.git ~/Documents/projects2024/rrr-demo\n変更の同期 git pull, git fetch\nクローンしたリポジトリはローカルリポジトリとして扱うことができます。\n\n\n4.5.3 GitHub Issues\nプロジェクトに関する問題やメモのために利用できます。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>バージョン管理</span>"
    ]
  },
  {
    "objectID": "git.html#バージョン管理の流れ再び",
    "href": "git.html#バージョン管理の流れ再び",
    "title": "4  バージョン管理",
    "section": "4.6 バージョン管理の流れ再び",
    "text": "4.6 バージョン管理の流れ再び\nコミット後のステップとして、以下が追加されます。\n\nリモートリポジトリの指定\nファイルのプッシュ\n\ngit remote add\n\n4.6.1 ファイルのプッシュ\nコミットを行ったら、変更を確定させるためのプッシュを行います。 プッシュを行うことで、リモートリポジトリに変更内容が反映されます。\ngit push",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>バージョン管理</span>"
    ]
  },
  {
    "objectID": "git.html#gitignore",
    "href": "git.html#gitignore",
    "title": "4  バージョン管理",
    "section": "4.7 .gitignore",
    "text": "4.7 .gitignore\nGitバージョン管理を行うリポジトリでは、バージョン管理に含めるべきではないファイルが存在します。 例えば、セキュリティ上重要な情報を含むファイルやキャッシュファイルなどです。 これらがバージョン管理に含まれると、セキュリティリスクが高まったり、リポジトリのサイズが大きくなるなどの問題が発生します。 実際に、GitHubなどのリモートリポジトリにデータベースの接続情報やAPIキーなどの機密情報が含まれていると、悪意のある第三者によって悪用される可能性があります。\nGitでは.gitignoreにバージョン管理の対象外とするファイルを記録することで、上記の問題の解決を図っています。 バージョン管理を行わないファイルの指定方法は、gitignoreにそのファイル名や名称のパターンを記述することで行います。 .gitignoreファイルはリポジトリ内の任意の場所に配置することができますが、通常はリポジトリのルートディレクトリ、.git/フォルダと同じ階層に配置します。\n.gitignoreに記録するファイルはプロジェクトによって異なりますが、一般的にバージョン管理から除外される種類のファイルが存在します。 特にファイルやフォルダ名の先頭に . が付いているものは、バージョン管理から除外することが一般的です。 こうしたファイルやフォルダは隠しファイル、隠しフォルダと呼ばれ、システムによって生成され、ユーザーが直接操作することは限定的です。 加えて、サイズが大きかったり差分管理が困難なバイナリファイルはバージョン管理の対象外となることが多いです。\n.gitignoreの記載例を示します。.gitignoreでは特定の正規表現を使って複数のファイルを指定したり、否定の表現（つまり管理に含める）を使った柔軟な指定が可能です。\nThumbs.db\n.DS_Store\n.Rproj.user\n.Rhistory\n.RData\n.Ruserdata\n*.pdf\n*.log\nREADME.html\nThumbs.dbや.DS_Storeは目にしたことがない方もいるかもしれません。 これらはWindowsやmacOSで生成されるファイルで、フォルダ内のファイルのサムネイルや表示方法を記録するファイルです。 プロジェクト内のコードには影響を与えないため、バージョン管理は不要です。\n続いての.Rproj.userから.RuserdataはRに関連するものです。 特に.Rproj.userはRStudioのプロジェクト設定ファイルを含むフォルダでバージョン管理を行いません。 .Rhistoryや.RDataはRの履歴やデータを保存するファイルですが、ユーザーやセッションの度に更新されるものであるため、これらもバージョン管理を行いません。\n*.pdf、*.logはPDFおよびlog形式のファイル一式を除外する指示です。ファイル名に関わらず、拡張子によって除外される複数のファイルを想定しています。 アスタリスク（*）は任意の文字列を表し、*.pdfは拡張子が.pdfであるファイルをすべて指定します。\n拡張子による指定という点で、その次の行 README.html も同様ですが、*.pdfや*.logと異なるのはプロジェクト内のすべてのHTMLファイルを除外するわけではないという点です。 README.htmlは特定のファイル名を指定しています。つまり対象外となるのは1つのファイルだけです。\n.Rprofileはバージョン管理に含めるか悩むところですが、 Rの設定や挙動を制御する内容が書かれているものであればバージョン管理するべきです。 プロジェクトに参加するすべてのメンバーが同じ条件でRを実行するために必要となる可能性があります。 一方で、.Rprofileに個人の機密情報や認証情報が含まれるのであれば.gitignoreに追加しましょう。\nクレデンシャルな情報を扱う必要があるのであれば、.Renvironや.Renviron.siteを使って環境変数として設定することを検討してください。 これらの情報は手間がかかるかもしれませんが、セキュリティ上のリスクを軽減するためには必要な対応です。 第6章では、configパッケージを使った環境変数の管理について紹介します。\n最後に、作成した覚えのないファイルやフォルダがGitバージョン管理の対象となっているときは、注意してそのファイルをバージョン管理に含めるべきかを検討してください。 著者の経験では、身に覚えのないファイルは一時的に生成されたものや成果物であることが多く、バージョン管理の対象外とすることが多いです。\n\n\n\n\n横田紋奈, と 宇賀神みずき. 2022. いちばんやさしいGit & GitHubの教本 : 人気講師が教えるバージョン管理&共有入門. 第2版 版. インプレス. https://ndlsearch.ndl.go.jp/books/R100000002-I032013125.\n\n\n渡辺宙志. 2024. ゼロから学ぶGit/GitHub : 現代的なソフトウェア開発のために. 講談社. https://ndlsearch.ndl.go.jp/books/R100000002-I033407628.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>バージョン管理</span>"
    ]
  },
  {
    "objectID": "document.html",
    "href": "document.html",
    "title": "5  ドキュメントの作成",
    "section": "",
    "text": "5.1 文芸的プログラミング\n通常のコンピュータプログラミングでは、プログラムのソースコードと実行結果は別々に扱われます。 コードと結果の関連性が失われている状態です。\n例えばRの場合、スクリプトファイルにコードを書いて実行すると、コンソールに結果が表示されます。 コンソールに表示された結果をコピーして、別のファイルに貼り付けることで、ソースコードと結果を一つのファイルにまとめることができますが、コピーをし忘れたり、間違って貼り付けたりすることがあります。 またこのような作業では、データや処理内容を変更する度に上書きの必要性が生じるので手間がかかります。\n文芸的プログラミングは、ソースコードと結果を含めた関連するドキュメントを一つのファイルにまとめることで、コードと結果の関連性を保ちながらドキュメントを作成する方法です。 コードの変更に伴って出力結果も自動的に更新されるため、手作業でのコピー&ペースト作業が不要になります。 このように動的に生成されるドキュメントを作成するツールとして、R MarkdownやJupyter Notebook(Jupyter)が有名です。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>ドキュメントの作成</span>"
    ]
  },
  {
    "objectID": "document.html#quarto",
    "href": "document.html#quarto",
    "title": "5  ドキュメントの作成",
    "section": "5.2 Quarto",
    "text": "5.2 Quarto\nQuartoはPositがオープンソースで開発している動的ドキュメント作成システムです。 Jupyterやプレーンテキストで書かれたファイルをもとに、HTMLやPDF、Wordなどのさまざまな形式でのドキュメントを作成することができます。 Rだけでなく、PythonやJuliaなどのプログラミング言語にも対応しています。\nRユーザにとっては、動的ドキュメントの作成にR Markdownを使うことが一般的ですが、QuartoはR Markdownの後継としても位置づけられています。 そのため、R Markdownの機能をほぼそのまま利用することができます。 実際、QuartoでのR言語の評価はR Markdown同様、knitrパッケージを介して行われます。\nここではQuartoの基本的な使い方として単一のドキュメント生成の手順を紹介します。 一方、Quartoにはウェブサイト、ブログ、書籍執筆をサポートする機能もあります。 これらのQuartoの詳細については公式ドキュメントを参照してください。\nR Markdownの基礎は 松村優哉 ほか (2021) にまとまっています。\n\n5.2.1 Quartoによるドキュメントの作成\nQuartoでは、.qmdという拡張子のファイルを作成し、その中にコードと必要な文章を記述します。 .qmdファイルをもとに任意の形式でのドキュメントを生成します。 .qmdファイルの基本構成は以下の通りです。\n\nフロントマター… ドキュメントのメタデータ（タイトルや著者名、出力形式などの実行オプション等）を記述する部分。YAML形式で記述します。\n文章… ドキュメントの本文。プレーンテキストに加えて、Markdown記法による文字装飾、LaTeX記法による数式記述が可能です。\nコードブロック（コードセル）1 …\n\n\n\n\nQuartoの基本構成要素\n\n\nファイルの先頭にYAMLの形式でメタデータを記述します。 以降はドキュメントの文章とコードとなります。\nコードブロックの宣言は、R Markdown同様、バッククォート(`)を使います。 コードブロックの宣言部分には {} の中に言語名を記述します。 Rの場合はr、Pythonではpython、Juliaではjuliaとなります。\nコードブロックには、プログラムやその出力に関する挙動を制御する実行オプションを記述できます2。 指定可能なオプションとして、echo（コードの表示有無）、eval（コードの評価有無）、図のサイズやキャプションなどがあります。\nコードブロックの実行オプションは以下のように記述します。 コードブロックの上部に#|を記述し、その後にオプション名とパラメータを記述します。 論理値での指定が必要な実行オプションはtrueまたはfalseで指定します。 Rの論理値の指定はすべて大文字で行いますが、ここではすべて小文字で表記するので注意してください。\n```{r}\n#| eval: true\n#| echo: false\n#| fig-width: 5\n#| fig-height: 5\n#| fig-cap: \"グラフの描画\"\nlibrary(ggplot2)\n\nmtcars |&gt; \n  ggplot(aes(x = wt, y = mpg)) +\n  geom_point() +\n  labs(title = \"燃費と重量の関係\")\n```\n必要な文章とコードを記載したら、Quartoのコマンドを使ってドキュメントを生成します。 .qmdファイルからのドキュメント生成の工程を、Quartoではレンダーと呼びます。 レンダーは.qmdファイルだけでなく、Jupyterで使われる.ipynbファイルからも行うことができます。\nレンダーはコマンドラインを使って以下のように行います。\nquarto render document.qmd --to html\nこのコマンドを実行するとdocument.qmdファイルをもとにHTML形式のドキュメントを生成します。 出力形式をWordファイルに変更する場合は、--toオプションの引数をdocxに変更するだけです。\nquarto render document.qmd --to docx\nRStudioやVS Codeなどのアプリケーションでは、Quartoのコマンドを実行するためのインターフェースが提供されています。 これにより、コマンドの入力の手間がなくなり、より直感的にQuartoを使うことができます。\n\n\n5.2.2 RStudioでのQuartoの利用\nQuartoの機能を試すために、RStudioで新しい.qmdファイルを作成してみましょう。 Quartoが利用可能な状況であれば、RStudioからQuartoを使うことができます。 メニューから「File」、「New File」、「Quarto Document…」の順に進むと以下のような画面が表示されます。\n\n\n\nRStudioでのqmdファイルの新規作成。Editorの箇所にチェックを入れるとビジュアルモードでの編集が可能となる（後述）\n\n\nタイトルや出力形式を指定して「Create」ボタンをクリックすると新しい.qmdファイルが作成されます。 また、エンジンとしてKnitrかJupyterが選択可能です。Knitr、つまりRのエンジンであってもreticulateパッケージにより Pythonの実行ができますが、Jupyterを指定することで直接Pythonの実行が可能になります。\nソースペインに新たに作成されたファイル内にコードと文章を記述して、レンダーを行います。 レンダーはソースペイン上の「Render」ボタンより実行します。ボタンをクリックすると、バックグラウンドでquartoのコマンドが実行され、.qmdファイル中のソースコードの実行結果をもとに指定した形式のドキュメントが生成されます。\nRStudioでは、Ctrl+Alt+I（macOSではCommand+Option+I）のショートカットキーを使うことで、コードブロックを追加できます。 このショートカットキーを使うと、コードブロックのエンジンとして{r}が自動的に挿入されます。\nレンダーのとき、通常コードブロックの評価はコードの上部に記載されたものから行われますが、 その場での実行も可能です。 これはレンダーをする前に結果を確認するのに役立ちます。 対象のコードが書かれた行にカーソルを置いてCtrl+Enter（macOSではCommand+Enter）を押すことで、そのコードを実行できます。 コードブロック全体のコードを実行するには、Ctrl+Shift+Enter（macOSではCommand+Shift+Enter）を使います。 あるいは、コードブロックの右上にある右向きの三角形ボタンをクリックすることでも実行できます。\n\n\n\n\nRStudioでのqmdファイルのインタラクティブ操作\n\n\n文字装飾、図や数式、参考文献等の挿入結果を表示しながら、ファイルを編集するときにはビジュアルモードの利用が便利です。 ビジュアルモードは、ソースペイン中にある編集中のqmdファイルのタブで「Visual」を選択すると切り替わります。 あるいはフロントマターでeditor: visualを宣言しておくことで、ファイルを開いたときにビジュアルモードが自動的に適用されます。\n\n\n5.2.3 PositronでのQuartoの利用\nPositronもRStudio同様に、qmdファイルのインタラクティブな編集と実行をサポートしています。 レンダーやビジュアルモードの切り替えも可能です。 RStudioと異なるのは、Positronではipynbファイルの編集・実行ができる点です。\n\n\n\nPositronでのqmdファイルの編集。コードブロック中のコード実行、レンダーボタンの配置はRStudioと同様。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>ドキュメントの作成</span>"
    ]
  },
  {
    "objectID": "document.html#pdfの出力",
    "href": "document.html#pdfの出力",
    "title": "5  ドキュメントの作成",
    "section": "5.3 PDFの出力",
    "text": "5.3 PDFの出力\nQuartoで日本語のPDFを生成する場合、2つの選択肢があります。 一つは出力形式を指定する際にpdfを指定する方法です。これはLaTeXを使ってPDFを生成する方法です。 もう一つの方法はtypstを出力形式として指定する方法です。 まずは一般的なLaTeXによるPDF出力方法を見てみましょう。\n\n5.3.1 LaTeX\nLaTeXを使ったPDF出力を行う場合、事前にLaTeXの環境を揃える必要があります。\nQuartoのコマンドからもLaTeX環境を導入可能です。\nquarto install tinytex\nこのコマンドを実行すると、TinyTeXというLaTeXディストリビューションがインストールされます。 ここまでで最低限のPDF出力環境が整います。\n新規で.qmdファイルを作成する手順を思い出し、出力形式をPDFにして作成してみましょう。 フロントマターのformatの項目がpdfになっていることを確認してください。 ファイルを編集してレンダーを行ってファイルを出力する点はこれまでの手順と同じです。\n\n\n\n\n\n\nLaTeXでの日本語のPDF出力\n\n\n\nLaTeXを使ったPDF出力を行う際、いくつか追加設定が必要な場合があります。 以下は日本語を扱うPDFの生成のためのフロントマターの指定例です。\n---\ntitle: \"日本語を含んだPDF\"\nformat: \n  pdf:\n    include-in-header:\n      text: |\n        \\usepackage{zxjatype}\n        \\usepackage[ipaex]{zxjafont}\n        \\setmainfont{IPAexGothic}\n---\nLaTeXのパッケージであるzxjatypeとzxjafontを使って日本語の組版、フォントを指定しています。 日本語フォントの種類としてIPAexGothicを指定していますが、他のフォントを指定することも可能です。 詳細はzxjafontのドキュメントをご覧下さい。\n\n\n\n\n5.3.2 Typst\n次にTypstを利用したPDF出力方法を紹介します。 TypstはHTMLなどと同じマークアップ言語の一種です。 LaTeXの高度で柔軟な組版システムとWordやGoogleドキュメントなどのツールの代替となるように設計された新しい組版システムです。\nバージョン1.4以降のQuartoでは、標準的にTypstが利用可能です。 フロントマターでformat: typstを指定するか、コマンドラインで--to typstを指定することでTypstによるPDFの生成が可能です。\n\n\n\n\n\n\nTypstでの日本語のPDF出力\n\n\n\nLaTeXを使ったPDF出力を行う際、いくつか追加設定が必要な場合があります。 以下は日本語を扱うPDFの生成のためのフロントマターの指定例です。\n---\ntitle: \"日本語を含んだPDF\"\nformat: \n  typst:\n    mainfont: \"Noto Sans JP\"\n---",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>ドキュメントの作成</span>"
    ]
  },
  {
    "objectID": "document.html#gtパッケージによる表出力",
    "href": "document.html#gtパッケージによる表出力",
    "title": "5  ドキュメントの作成",
    "section": "5.4 gtパッケージによる表出力",
    "text": "5.4 gtパッケージによる表出力\nドキュメントで表を利用することは、目的が学術的であろうとビジネス向けであろうと頻繁に行われます。 Rには、R MarkdownやQuartoで表を出力するパッケージが豊富に存在します。 これらのパッケージを使うことで、綺麗な表出力が可能になります。\ngtパッケージはデータフレーム形式のオブジェクトを表として出力します。 HTMLやLaTeX、RTFでの出力が可能で、さまざまなドキュメントで利用可能です。 表に求められるタイトルやキャプションの表示はもちろん、出力時のフォーマットや塗りつぶしの色の指定などが柔軟に行える特徴があります。\nデータフレームを対象として、gt()関数を適用します。 mtcarsデータを例に、gt()関数を適用してみましょう。\n\nlibrary(gt)\n\ngttbl &lt;- \n  head(mtcars) |&gt; \n  gt()\n\ngttbl\n\n\n\n\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\n18.1\n6\n225\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n\n\n\n\n\n\n\n表の見た目の変更は、作成したgt_tblオブジェクトに対して、処理を追加する形で行います。 例えば表の見出し、副見出しを指定するにはtab_header()関数を追加し、 列の見出しの背景色を指定するにはtab_options()関数を追加します。\n\ngttbl |&gt; \n  tab_header(\n    title = \"mtcars\",\n    subtitle = \"先頭6行を表示\"\n  ) |&gt; \n   tab_options(\n    column_labels.background.color = \"gray\"\n  )\n\n\n\n\n\n\n\nmtcars\n\n\n先頭6行を表示\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\n18.1\n6\n225\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n\n\n\n\n\n\n\ngtパッケージはグループ化\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nmtcars |&gt; \n  select(cyl, disp, hp, drat, wt, qsec) |&gt;\n  group_by(cyl) |&gt;\n  gt() |&gt; \n   summary_rows(\n    groups = everything(),\n    columns = c(disp, disp, hp, drat, wt, qsec),\n    fns = list(\n      average = \"mean\",\n      total = \"sum\",\n      SD = \"sd\"\n    )\n  ) |&gt; \n  grand_summary_rows(\n    columns = c(disp, disp, hp, drat, wt, qsec),\n    fns = list(\n      average = \"mean\",\n      total = \"sum\",\n      SD = \"sd\"\n    )\n  ) |&gt; \n  tab_options(\n    summary_row.background.color = \"lightblue\",\n    grand_summary_row.background.color = \"lightgreen\")\n\n\n\n\n\n\n\n\ndisp\nhp\ndrat\nwt\nqsec\n\n\n\n\n6\n\n\n\n160.0\n110\n3.90\n2.620\n16.46\n\n\n\n160.0\n110\n3.90\n2.875\n17.02\n\n\n\n258.0\n110\n3.08\n3.215\n19.44\n\n\n\n225.0\n105\n2.76\n3.460\n20.22\n\n\n\n167.6\n123\n3.92\n3.440\n18.30\n\n\n\n167.6\n123\n3.92\n3.440\n18.90\n\n\n\n145.0\n175\n3.62\n2.770\n15.50\n\n\nmean\n183.31429\n122.28571\n3.5857143\n3.1171429\n17.977143\n\n\nsum\n1283.20000\n856.00000\n25.1000000\n21.8200000\n125.840000\n\n\nsd\n41.56246\n24.26049\n0.4760552\n0.3563455\n1.706866\n\n\n4\n\n\n\n108.0\n93\n3.85\n2.320\n18.61\n\n\n\n146.7\n62\n3.69\n3.190\n20.00\n\n\n\n140.8\n95\n3.92\n3.150\n22.90\n\n\n\n78.7\n66\n4.08\n2.200\n19.47\n\n\n\n75.7\n52\n4.93\n1.615\n18.52\n\n\n\n71.1\n65\n4.22\n1.835\n19.90\n\n\n\n120.1\n97\n3.70\n2.465\n20.01\n\n\n\n79.0\n66\n4.08\n1.935\n18.90\n\n\n\n120.3\n91\n4.43\n2.140\n16.70\n\n\n\n95.1\n113\n3.77\n1.513\n16.90\n\n\n\n121.0\n109\n4.11\n2.780\n18.60\n\n\nmean\n105.13636\n82.63636\n4.0709091\n2.2857273\n19.137273\n\n\nsum\n1156.50000\n909.00000\n44.7800000\n25.1430000\n210.510000\n\n\nsd\n26.87159\n20.93453\n0.3654711\n0.5695637\n1.682445\n\n\n8\n\n\n\n360.0\n175\n3.15\n3.440\n17.02\n\n\n\n360.0\n245\n3.21\n3.570\n15.84\n\n\n\n275.8\n180\n3.07\n4.070\n17.40\n\n\n\n275.8\n180\n3.07\n3.730\n17.60\n\n\n\n275.8\n180\n3.07\n3.780\n18.00\n\n\n\n472.0\n205\n2.93\n5.250\n17.98\n\n\n\n460.0\n215\n3.00\n5.424\n17.82\n\n\n\n440.0\n230\n3.23\n5.345\n17.42\n\n\n\n318.0\n150\n2.76\n3.520\n16.87\n\n\n\n304.0\n150\n3.15\n3.435\n17.30\n\n\n\n350.0\n245\n3.73\n3.840\n15.41\n\n\n\n400.0\n175\n3.08\n3.845\n17.05\n\n\n\n351.0\n264\n4.22\n3.170\n14.50\n\n\n\n301.0\n335\n3.54\n3.570\n14.60\n\n\nmean\n353.10000\n209.21429\n3.2292857\n3.9992143\n16.772143\n\n\nsum\n4943.40000\n2929.00000\n45.2100000\n55.9890000\n234.810000\n\n\nsd\n67.77132\n50.97689\n0.3723618\n0.7594047\n1.196014\n\n\nmean\n230.7219\n146.68750\n3.5965625\n3.2172500\n17.848750\n\n\nsum\n7383.1000\n4694.00000\n115.0900000\n102.9520000\n571.160000\n\n\nsd\n123.9387\n68.56287\n0.5346787\n0.9784574\n1.786943\n\n\n\n\n\n\n\n\n\n\n\n松村優哉, 湯谷啓明, 紀ノ定保礼, と 前田和寛. 2021. RユーザのためのRStudio〈実践〉入門 : tidyverseによるモダンな分析フローの世界. 技術評論社. https://gihyo.jp/book/2021/978-4-297-12170-9.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>ドキュメントの作成</span>"
    ]
  },
  {
    "objectID": "document.html#footnotes",
    "href": "document.html#footnotes",
    "title": "5  ドキュメントの作成",
    "section": "",
    "text": "コードを記述する箇所。Jupyterではコードセルと呼ばれます。↩︎\nドキュメント全体での制御はフロントマター内で行います。個別のコードブロックに対して記述したオプションが優先されます。実行オプションの詳細はQuarto公式ページのドキュメントに記載されています。↩︎",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>ドキュメントの作成</span>"
    ]
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "6  再現性を高めるRパッケージ",
    "section": "",
    "text": "6.1 renvパッケージ\n複数環境でRを実行する際は、ある環境では必要なパッケージがインストールされていなかったり、インストール済みであってもバージョンが異なることがあります。 このような環境間でのパッケージの違いは、対象のパッケージの特定のバージョンをインストールすれば解決することですが、パッケージが多い場合はその作業が苦痛になります。\nrenvパッケージは、プロジェクトごとに必要なパッケージを管理するためのRパッケージです。 通常は一つのパッケージに対して利用可能なバージョンは一つだけですが、renvを用いれば、プロジェクトごとに異なるバージョンのパッケージを利用可能になります。 その仕組みは、renvを使ってインストールされるパッケージは、通常のRのパッケージのインストール先とは異なる場所にインストールされるためです。 renvを使わないプロジェクトに影響することはありません。\nインストールされるパッケージは将来利用するプロジェクトでも再利用されます。 たくさんのパッケージを利用するプロジェクトでは、本来すべてのパッケージを揃えるのに時間がかかりますが、renvではキャッシュ機能によって、再インストール時の時間の短縮化を行います。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>再現性を高めるRパッケージ</span>"
    ]
  },
  {
    "objectID": "packages.html#renvパッケージ",
    "href": "packages.html#renvパッケージ",
    "title": "6  再現性を高めるRパッケージ",
    "section": "",
    "text": "6.1.1 renvプロジェクトの開始\nrenvでパッケージの管理を行うには、以下のコードを実行し、準備する必要があります。\n\n# renvパッケージの読み込み\n# renvパッケージの関数名は短いものが多いため、ここではパッケージ読み込み後も renv::関数名の表記を行う\nlibrary(renv)\n\n\nrenv::init()\n\nrenv::init()関数の実行により、プロジェクト中に.Rprofileとrenv.lockの2つのファイルとrenvフォルダが作成されます。 .Rprofileにはrenvによる管理を行うことを示す1行分のコードが記述されいます。 renv::init()を実行する前に、すでに.Rprofileが存在する場合、1行追加されるだけで既存の内容は残ります。\nバージョン管理システムを使っている場合、renv.init()関数で生成されたファイルはいずれもバージョン管理に含めることになります。 .Rprofileに記録されたrenv利用のコードがなければ、自分以外はrenvを利用できませんし、renv.lockがなければ、他の人が同じ環境を再現することができないためです。\n\n\n6.1.2 パッケージの管理\nrenvを使ったプロジェクトでは、保存されたRファイルやRmd(.rmd）、.qmdの中で使われるRパッケージを管理対象にします。renv::status()`関数を使うと、プロジェクト中のソースコードを再現するのに必要なパッケージのインストール状況について、下記のような確認が行われます。\n\nrenv::status()\n#&gt; The following package(s) are in an inconsistent state:\n#&gt; \n#&gt;  package     installed recorded used\n#&gt;  clipr       y         n        y   \n#&gt;  credentials y         n        y   \n#&gt;  gert        y         n        y   \n#&gt;  gh          y         n        y   \n#&gt;  gitcreds    y         n        y   \n#&gt;  ini         y         n        y   \n#&gt;  reprex      y         n        y   \n#&gt;  usethis     y         n        y   \n#&gt;  zip         y         n        y   \n#&gt; \n#&gt; See ?renv::status() for advice on resolving these issues.\n\ninstalledはインストール状態を示す列です。 yならパッケージはインストールされています。 recordedはrenv.lockに記録されているかどうかを示します。 上記の例ではいずれもnとなっています。 usedはプロジェクトで利用されているかどうかを示します。\n次に行う行動は、installedがnの未パッケージをインストールし、 recordedがn、usedがyのパッケージをrenv.lockに記録することです。 これらの作業はrenv::snapshot()関数を使って行います。\n\nrenv::snapshot()\n#&gt;  The following package(s) will be updated in the lockfile:\n#&gt;  \n#&gt;  # CRAN -----------------------------------------------------------------\n#&gt;  - clipr         [* -&gt; 0.8.0]\n#&gt;  - credentials   [* -&gt; 2.0.1]\n#&gt;  - gert          [* -&gt; 2.1.1]\n#&gt;  - gh            [* -&gt; 1.4.1]\n#&gt;  - gitcreds      [* -&gt; 0.1.2]\n#&gt;  - ini           [* -&gt; 0.3.1]\n#&gt;  - reprex        [* -&gt; 2.1.1]\n#&gt;  - usethis       [* -&gt; 3.0.0]\n#&gt;  - zip           [* -&gt; 2.3.1]\n#&gt;  \n#&gt;  Do you want to proceed? [Y/n]: \n\nrenv::snapshot()の出力は、renv.lockの記録とCRANやリモートリポジトリのバージョンに基づいて行われます。 [* -&gt; 0.8.0]のように、矢印で示されている先が、新しく記録されるバージョンを示します。 対して矢印の元になる方はrenv.lockに記録されたバージョンを示しています。 *はrenv.lockに記録がないことを表します。 すでにrenv.lockに記録があるパッケージはそのバージョンが表示されます。\n記録を行うことに問題はないので、Yを入力してEnterキーを押します。 これによりrenv.lockの更新が確定されます。\nプロジェクトでの作業を進めていくと、利用するパッケージが次第に変化します。 そのためrenv.lockを定期的に更新することが重要です。 手順は今見てきたように、renv::status()での状況確認、続いてrenv::snapshot()関数でのバージョンを参考にしながらのrenv.lockの更新です。\nrenv::snapshot()関数実行時に、もしスナップショットからの変更がないのであれば、出力は以下のようになります。\n\nrenv::snapshot()\n#&gt; - The lockfile is already up to date.\n\n\n\n6.1.3 パッケージの追加・削除\nrenvでは、renv::snapshot()関数を使って自動的に利用されるパッケージをインストールしますが、ここでは原則として最新版がインストール対象となります。 しかし、特定のバージョンやGitHubの開発版を利用したい場面もあります。 このような状況のために、ユーザーが手動でパッケージの追加・削除を行うことも可能です。\nパッケージの追加は install.packages()関数か renv::install()関数を使って行います。 前者は通常のRと同じインストール方法です。 どちらの関数を使っても挙動は同じです。 ただし、renv::install()関数では、CRANにあるパッケージだけでなく、そのバージョンを指定することもできます。 また、GitHubやBioconductor上のパッケージもインストールの対象とすることが可能です。\n\n# CRAN上のパッケージのインストール\n# @以降にバージョンを指定することで、特定のバージョンをインストールできる\nrenv::install(\"jmastats@0.2.2\")\n\n# GitHub上のパッケージをインストール\n# GitHubのユーザー名/リポジトリ名の形式を指定する\nrenv::install(\"uribo/jpmesh\")\n\nパッケージの追加を行ったらrenv::snapshot()関数を実行して、プロジェクトのスナップショットを取りましょう。 適切にパッケージがインストールされている場合、renv.lockが更新されます。\nパッケージを削除するには、renv::remove()関数にパッケージ名を指定して実行します。 ただし、プロジェクト中のソースコードのどこかで削除したパッケージ、関数の呼び出しがある場合、renv::snapshot()関数を行ったときに再びインストールを促す出力が行われます。 完全にパッケージをプロジェクトで利用しないというときは、ソースコードからも削除することをお勧めします。\n\n# jpmeshパッケージを削除する\nrenv::remove(\"jpmesh\")\n\n\nrenv::snapshot()\n#&gt; The following required packages are not installed:\n#&gt; - jpmesh\n#&gt; Packages must first be installed before renv can snapshot them.\n#&gt; Use `renv::dependencies()` to see where this package is used in your project.\n#&gt; \n#&gt; What do you want to do? \n#&gt; \n#&gt; 1: Snapshot, just using the currently installed packages.\n#&gt; 2: Install the packages, then snapshot.\n#&gt; 3: Cancel, and resolve the situation on your own.\n\nここで1を選択すると、renv.lockからの削除も行われます。 一方、2を選ぶと再度インストールを実行し、renv.lockの更新が行われます。\n\n\n6.1.4 パッケージの復元\nリモートリポジトリからのクローンや、他の環境からrenvを使ったプロジェクトで作業を始める際は、renv::restore()関数によってrenv.lockに記録されたパッケージをインストールします。 これにより、プロジェクトで使われるパッケージが揃い、再現性の向上に役立ちます。 もし他のプロジェクトで同一パッケージの同一バージョンが利用されていた場合、キャッシュが使われるためにインストール時間が短縮されます。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>再現性を高めるRパッケージ</span>"
    ]
  },
  {
    "objectID": "packages.html#pointblankパッケージ",
    "href": "packages.html#pointblankパッケージ",
    "title": "6  再現性を高めるRパッケージ",
    "section": "6.2 pointblankパッケージ",
    "text": "6.2 pointblankパッケージ\nデータ分析を行う上で、データは変化することがあります。 特定のデータについて問題が見つかったために除外されたり、新たなデータが得られたりすることがあるからです。 データが更新されること自体は珍しいことではありませんが、変更内容によっては分析結果に大きく影響を及ぼすことがあり、注意が必要です。\nまた、データ分析の過程で、データの品質に問題が生じることもあります。 これには、予想外の値や欠損値の混入、データの形式の不整合などが含まれます。 これらの問題に気がつかないまま分析を進めると、誤った結果を導くことになりかねません。 そのため、データの品質は常に確認しておくべきです。\n次に紹介するパッケージは、データの品質を検証するpointblankパッケージです。 データフレームに対して、事前に用意したさまざまな検査関数を適用することで、データの変化による問題を検知することを可能にします。\n\n# pointblankパッケージの読み込み\nlibrary(pointblank)\n\npointblankパッケージによる検査は、その場での実行と、レポート形式での出力の2つの方法で行われます。 検査対象は、ローカル環境にあるデータフレームが前提となりますが、データベースやSparkなどのリモートデータに対しても検査が可能です。\n多様な検査関数や、出力形式、リモートデータの指定などの詳細は、公式ドキュメントを参照してください。 ここではまず、pointblankによるデータ検査の基本的な手順を紹介します。\n例として、mtcarsデータを対象にデータ検査を行いますが、準備として以下の処理で、行名をcar列として取り扱うようにし、tibble形式に変換しておきます。\n\nmtcars_mod &lt;- \n  mtcars |&gt; \n  tibble::rownames_to_column(var = \"car\") |&gt; \n  tibble::as_tibble()\n\n\n6.2.1 データ検査の基本\npointblankのデータ検査は、データフレームに検査関数を適用する形で実行されます。 検査関数は、データの品質・状態を確認するための関数で、データの行数や列数、特定の列の値の範囲などを検査します。 以下のコードでは、row_count_match()関数を使って、データフレームの行数が指定した値と一致するかどうかを確認しています。 予期された件数と一致する場合、検査は成功となり、データフレームの内容が返却されます。\n\nmtcars_mod |&gt; \n  row_count_match(32L)\n\nでは、検査に失敗するとどうなるか見てみましょう。 次のコードでは、col_vals_between()関数を使って、disp列の値が75から470の範囲に収まるかを検査しています。\n\nmtcars_mod |&gt; \n  col_vals_between(vars(disp), 75, 470)\n\nError: Exceedance of failed test units where values in `disp` should have been between `75` and `470`.\nThe `col_vals_between()` validation failed beyond the absolute threshold level (1).\n* failure level (2) &gt;= failure threshold (1)\n\n\nエラーメッセージが出力され、処理が停止しました。 pointblankによる検査は、事前に用意したデータの品質と相違がある場合、エラーを返すことで問題を通知します。 これにより、意図しないデータの変更を防ぎ、分析結果の信頼性を高めることができます。\n実際にmtcarsデータのdispの範囲がどうなっているか、確認し、先ほどのコードを修正してみましょう。\n\nrange(mtcars_mod$disp)\n\n[1]  71.1 472.0\n\n\n\n# range()関数の出力に基づき、範囲を修正する\nmtcars_mod |&gt; \n  col_vals_between(vars(disp), 71, 472)\n\n今度は問題なく検査が完了しました。\n検査関数は、複数の関数を組合せて使うこともできます。 パイプ演算子を用いてコードを記述すると、検査の手順が明確になり、データの品質を確認しやすくなります。 行数と範囲の検査を一つの処理で実行します。\n\nmtcars_mod |&gt; \n  row_count_match(32L) |&gt; \n  col_vals_between(vars(disp), 71, 472)\n\n検査で不備が見つかるとエラーになることは既に確認しましたが、 複数の検査項目について検査を行う場合には、処理を継続させる必要があります。 そのためのオプションとして、actions引数での検査診断結果の閾値を調整できます。 actions引数には、action_levels()関数あるいはwarn_on_fail()関数などのヘルパー関数を与えて、検査結果に対するアクションを指定します。\n\n# warn_on_fail()関数でも同様\nal &lt;- \n  action_levels(warn_at = 1)\n\n# 検査は失敗するが、エラーではなく警告として処理される。\nmtcars_mod |&gt; \n  col_vals_between(vars(disp), 75, 470, actions = al)\n\nWarning: Exceedance of failed test units where values in `disp` should have been between `75` and `470`.\nThe `col_vals_between()` validation failed beyond the absolute threshold level (1).\n* failure level (2) &gt;= failure threshold (1)\n\n\n\n\n6.2.2 エージェントによる検査とレポートの作成\n次に、エージェントと呼ばれる仕組みを用いて、データ検査を行う方法を紹介します。 エージェントを利用することで、検査結果をレポートとして出力することができます。\nはじめにcreat_agent()関数でエージェントを作成し、その後検査関数を適宜追加していきます。\n\nal &lt;- action_levels(warn_at = 0.1, stop_at = 0.2)\n\nagent &lt;- \n  create_agent(mtcars_mod,\n               label = \"pointblankによるデータ品質検査\",\n               actions = al) |&gt; \n  col_vals_not_null(vars(mpg)) |&gt;\n  col_vals_in_set(car, set = c(\"Merc 450SL\")) |&gt; \n  col_is_numeric(vars(cyl, vs, am, gear)) |&gt; \n  col_is_factor(vars(carb)) |&gt; \n  col_exists(price)\n\n検査項目の追加が完了したら、interrogate()関数を使って検査を実行します。 検査が完了すると、検査結果がレポート1として出力されます。\n\ninterrogate(agent)\n\n\n\n\n\n\n\nPointblank Validation\n\n\npointblankによるデータ品質検査\n\ntibble mtcars_modWARN 0.10 STOP 0.20 NOTIFY —\n\n\n\n\n\nSTEP\nCOLUMNS\nVALUES\nTBL\nEVAL\nUNITS\nPASS\nFAIL\nW\nS\nN\nEXT\n\n\n\n\n\n\n1\n\n\n\n\ncol_vals_not_null\n\n       \n\n\n col_vals_not_null()\n\n\n▮mpg\n\n—\n\n\n      \n\n\n✓\n32\n32\n1\n0\n0\n○\n○\n—\n—\n\n\n\n\n2\n\n\n\n\ncol_vals_in_set\n\n     \n\n\n col_vals_in_set()\n\n\n▮car\n\n\nMerc 450SL\n\n\n\n      \n\n\n✓\n32\n1\n0.03125\n31\n0.96875\n●\n●\n—\n\n\nCSV\n\n\n\n\n\n\n3\n\n\n\n\ncol_is_numeric\n\n      \n\n\n col_is_numeric()\n\n\n▮cyl\n\n—\n\n\n      \n\n\n✓\n1\n1\n1\n0\n0\n○\n○\n—\n—\n\n\n\n\n4\n\n\n\n\ncol_is_numeric\n\n      \n\n\n col_is_numeric()\n\n\n▮vs\n\n—\n\n\n      \n\n\n✓\n1\n1\n1\n0\n0\n○\n○\n—\n—\n\n\n\n\n5\n\n\n\n\ncol_is_numeric\n\n      \n\n\n col_is_numeric()\n\n\n▮am\n\n—\n\n\n      \n\n\n✓\n1\n1\n1\n0\n0\n○\n○\n—\n—\n\n\n\n\n6\n\n\n\n\ncol_is_numeric\n\n      \n\n\n col_is_numeric()\n\n\n▮gear\n\n—\n\n\n      \n\n\n✓\n1\n1\n1\n0\n0\n○\n○\n—\n—\n\n\n\n\n7\n\n\n\n\ncol_is_factor\n\n      \n\n\n col_is_factor()\n\n\n▮carb\n\n—\n\n\n      \n\n\n✓\n1\n0\n0\n1\n1\n●\n●\n—\n—\n\n\n\n\n8\n\n\n\n\ncol_exists\n\n      \n\n\n col_exists()\n\n\n▮price\n\n—\n\n\n      \n\n\n✓\n1\n0\n0\n1\n1\n●\n●\n—\n—\n\n\n\n2024-08-30 04:50:16 UTC &lt; 1 s 2024-08-30 04:50:16 UTC\n\n\n\n\n\n\n\n\n\n\n6.2.3 データのスキャン\n検査関数を用意するには、事前にデータの状態を把握しておかなくてはなりません。 列の多いデータフレームでこれを行おうとすると手間がかかります。 そこでscan_data()関数の利用が有効です。 scan_data()関数は、データを分析し、検査に役立つ以下の項目を抽出し、レポートにまとめます。\n\n概要 (Overview): データのサイズ、欠損値を含む行数、重複のある行数、列の種類\n変数 (Variables): 変数の要約統計量\n相互作用 (Interactions): 変数の確率密度、変数間の散布図を含んだ散布図行列\n相関 (Correlations): 数値変数の相関行列の図\n欠損値 (Missing): 変数の欠損具合を示す図\nサンプル (Sample): データの先頭行と末尾行\n\nレポートに含める項目は、必要に応じて取捨選択や並び替えが可能です。 scan_data()関数のsections引数を使用すると、特定の項目だけを指定できるようになります。 指定される内容は、対象とする各項目の大文字頭文字を組み合わせた文字列です。 既定値として、すべての項目を含める”OVICMS”が与えられていますが、例えば概要と変数のみをレポートにまとめるのであれば”OV”を指定します。\n\n# データの概要と変数についてレポートを行う\nscan_data(mtcars_mod, sections = \"OV\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>再現性を高めるRパッケージ</span>"
    ]
  },
  {
    "objectID": "packages.html#pinsパッケージ",
    "href": "packages.html#pinsパッケージ",
    "title": "6  再現性を高めるRパッケージ",
    "section": "6.3 pinsパッケージ",
    "text": "6.3 pinsパッケージ",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>再現性を高めるRパッケージ</span>"
    ]
  },
  {
    "objectID": "packages.html#configパッケージ",
    "href": "packages.html#configパッケージ",
    "title": "6  再現性を高めるRパッケージ",
    "section": "6.4 configパッケージ",
    "text": "6.4 configパッケージ",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>再現性を高めるRパッケージ</span>"
    ]
  },
  {
    "objectID": "packages.html#footnotes",
    "href": "packages.html#footnotes",
    "title": "6  再現性を高めるRパッケージ",
    "section": "",
    "text": "ドキュメントの章で取り上げたgtテーブルが利用されています。↩︎",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>再現性を高めるRパッケージ</span>"
    ]
  },
  {
    "objectID": "workflow.html",
    "href": "workflow.html",
    "title": "7  ワークフロー",
    "section": "",
    "text": "7.1 targetopia",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ワークフロー</span>"
    ]
  },
  {
    "objectID": "workflow.html#targetopia",
    "href": "workflow.html#targetopia",
    "title": "7  ワークフロー",
    "section": "",
    "text": "tarchetypes\n\n\n\n\n\nigjit, atusy, と hanaori. 2022. Rが生産性を高める : データ分析ワークフロー効率化の実践. 技術評論社. https://ndlsearch.ndl.go.jp/books/R100000002-I031915796.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ワークフロー</span>"
    ]
  },
  {
    "objectID": "container.html",
    "href": "container.html",
    "title": "8  コンテナ",
    "section": "",
    "text": "8.1 Docker",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>コンテナ</span>"
    ]
  },
  {
    "objectID": "reference.html",
    "href": "reference.html",
    "title": "参考文献",
    "section": "",
    "text": "igjit, atusy, and hanaori. 2022. Rが生産性を高める :\nデータ分析ワークフロー効率化の実践. 技術評論社. https://ndlsearch.ndl.go.jp/books/R100000002-I031915796.\n\n\n松村優哉, 湯谷啓明, 紀ノ定保礼, and 前田和寛. 2021.\nRユーザのためのRStudio〈実践〉入門 :\nTidyverseによるモダンな分析フローの世界. 技術評論社. https://gihyo.jp/book/2021/978-4-297-12170-9.\n\n\n横田紋奈, and 宇賀神みずき. 2022. いちばんやさしいGit &\nGitHubの教本 : 人気講師が教えるバージョン管理&共有入門. 第2版\ned. インプレス. https://ndlsearch.ndl.go.jp/books/R100000002-I032013125.\n\n\n渡辺宙志. 2024. ゼロから学ぶGit/GitHub :\n現代的なソフトウェア開発のために. 講談社. https://ndlsearch.ndl.go.jp/books/R100000002-I033407628.",
    "crumbs": [
      "参考文献"
    ]
  }
]